問題管理画面をVueJSで作成していただきたい。
生成したものは一括でダウンロードできるようzipに固めてください。
画面はVueコンポーネントを正しく分割していただきたい。UI要素はVuetifyを利用する。
問題管理画面には問題詳細画面と浮くウィンドーの問題詳細が含む。
初期表示にバックエンド通信が発生するものに関して、vue skeletonを利用してダミーコンポーネントを一時表示する。
v-data-tableに関して、マウスがホバーする行がわかるようにしたい
以下、それぞれ画面の実現要素を記述する。

■問題管理画面
この画面は問題データを一覧で管理する画面になる。
この画面には編集モードと参照モードがある。
画面上は改ページで表示される。ページのサイズはプルダウンで選択可能。
問題データは画面初期表示時にバックエンドにリクエストする（１ページ目のみ）。サンプルは以下になる。
バックエンドから帰ってきたレスポンスをリストで画面に表示させる。
画面上は改ページで表示される。ページのサイズはプルダウンで選択可能。
ページボタンクリック、または、検索ボタンをクリックしたらバックエンドから内容を取得しなおす。
画面に検索条件を入れて、検索ボタンを押したらバックエンドにもう一度リクエストし、条件で検索結果を表示する。
検索条件には、問題ＩＤ（UUID）、スキルＩＤ、難易度レンジ、自動生成フラグ、問題文章（部分一致）という項目がある。
検索条件は折りたためるようにする。
追加登録ボタンは画面の上部にある。参照、編集、削除ボタンがデータ行の右側にある。
編集モードでは、問題データに対して、参照、削除、編集、追加登録が可能。
参照モードでは、問題データのみ参照可能。追加登録、編集、削除ボタンは非表示にする。
参照モードでは、問題データに対してクダブルリックしたら、選択した問題と関連する選択肢データを呼び出し元に返す。
編集モードは問題データをダブりクリックに特に処理しない。
編集に関しては、編集ボタンを押ししたら、その問題データの問題ＩＤが問題詳細画面に渡され、問題詳細画面のコンポーネントが浮きだす。
問題詳細画面で修正を行い終わったら、保存ボタンを押すと、バックエンドの保存完了後に浮いた画面が閉じられ、バックエンドにリクエストしなおす。
追加登録ボタンを押したら、同様に問題詳細画面が表示され、そこで問題の新規登録が終わったら閉じる。
問題詳細画面の保存ボタンを押すと、問題情報がバックエンドに送信されて、画面が閉じる。
削除ボタンを押すと、「削除しますか」という旨のモーダルが表示されて、「はい」と押したら、サーバー送信が行われ、当該データが削除される。
問題データの更新が発生した場合（問題データの削除もしくは問題詳細画面での更新、削除、新規登録）、
画面上に入力された既存条件でバックエンドから内容を取得しなおす。

■問題詳細画面
この画面は一つ特定の問題データの詳細を管理する画面になる。
画面上部にはＡＩ生成ボタン、保存ボタンと削除ボタンがある。
問題の選択肢はリストの形で画面上に表示される。リストの下部に選択肢追加のボタンがある。
問題詳細画面は参照モード、編集モード、新規登録モードと三種類がある。
新規登録モード以外の場合、問題ＩＤ（ＵＵＩＤ）が必須であり、画面初期時に呼び出す元のコンポーネントから渡される。
参照モードで開いた場合は、すべてのボタンが非表示になり、リストも非活性になる。
選択肢ＩＤは（ＵＵＩＤ）は新規登録時にバックエンドで採番されるため、非活性になる。

新規登録モードの場合、保存の際に問題ＩＤはバックエンドで採番するため、空で非活性で表示する。
新規登録モード以外の場合も、問題ＩＤが非活性で表示する。
保存ボタンを押すと問題データ、選択肢データがバックエンドに連携され、現在のデータを削除したうえDBに反映される。
削除ボタンを押すと問題ＩＤがバックエンドに連携され、ＤＢから問題と関連の選択肢データを含め、削除フラグを削除に更新する。
ＡＩ生成ボタンを押すと、バックエンドにAI生成リクエストして、バックエンドがAI生成の結果を返してくる。
※バックエンド処理は別途実装する。

■問題データのサンプル
以下のように画面上のサンプルは２０個生成してください
[
{
"問題ＩＤ": "f8b92b3a-7c5b-4b1c-a8b0-dc1f8a7d1b62",
"問題文章": "次のうち、Javaでオブジェクトを正しく比較する方法はどれですか？",
"難易度": 4,
"スキル": "Java",
"模範回答": "a3c37fbb-b6d4-49d0-a4f5-10d9ec0a1e9e",
"模範回答理由": "Javaでは、オブジェクトの内容比較にはequals()メソッドを使用する必要があるため。",
"自動生成フラグ": 0,
"選択肢": [
{
"選択肢ＩＤ": "a3c37fbb-b6d4-49d0-a4f5-10d9ec0a1e9e",
"選択肢文章": "equals()メソッドを使う",
"回答理由": "==は参照比較のため、オブジェクト内容を比較するにはequals()を使うべき。"
},
{
"選択肢ＩＤ": "21d3a61b-43cc-4bb7-a3d1-6b6b2b52c924",
"選択肢文章": "==演算子を使う",
"回答理由": "==は参照比較であり、異なるオブジェクトでも同内容ならfalseになる。"
},
{
"選択肢ＩＤ": "a42b4d8f-5f43-48a3-b35f-8e89b5dbac7a",
"選択肢文章": "compareTo()メソッドを使う",
"回答理由": "compareTo()は主にComparableを実装したクラスで大小比較に使う。"
},
{
"選択肢ＩＤ": "be22e8bb-5dc8-4af5-a3c8-86e474d51855",
"選択肢文章": "hashCode()を使う",
"回答理由": "hashCode()はハッシュ値比較であり、内容比較には不適切。"
}
]
},
{
"問題ＩＤ": "b1c2290f-8a3b-4f6e-9f9f-1c4a4a7cf4b8",
"問題文章": "Vue.jsで双方向バインディングを行うためのディレクティブはどれですか？",
"難易度": 3,
"スキル": "VueJS",
"模範回答": "c3b45a91-b112-4673-9051-f06b45ecb3d3",
"模範回答理由": "v-modelディレクティブは入力要素とデータの双方向バインディングを提供するため。",
"自動生成フラグ": 0,
"選択肢": [
{
"選択肢ＩＤ": "c3b45a91-b112-4673-9051-f06b45ecb3d3",
"選択肢文章": "v-model",
"回答理由": "双方向データバインディング用に特化したディレクティブ。"
},
{
"選択肢ＩＤ": "98e3c7de-2de9-4d84-a5d7-5fd7e60b0f71",
"選択肢文章": "v-bind",
"回答理由": "v-bindは片方向のプロパティバインディングに使用される。"
},
{
"選択肢ＩＤ": "cc04d1d1-23a3-469f-bd5a-0fa4b38f79cb",
"選択肢文章": "v-if",
"回答理由": "条件付きレンダリングのためのディレクティブであり、データバインディングとは無関係。"
},
{
"選択肢ＩＤ": "dd6d2b94-8182-48b7-8a13-6e3479f824cb",
"選択肢文章": "v-on",
"回答理由": "イベントリスナー登録用のディレクティブ。双方向バインディングではない。"
}
]
}
]
